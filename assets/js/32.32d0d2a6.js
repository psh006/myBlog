(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{825:function(a,t,s){"use strict";s.r(t);var e=s(114),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[a._v("#")]),a._v(" 浏览器")]),a._v(" "),s("h2",{attrs:{id:"浏览器页面渲染流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器页面渲染流程"}},[a._v("#")]),a._v(" 浏览器页面渲染流程")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1.解析HTML文件，构建DOM树\n2.解析CSS,构建CSS规则树\n3.将DOM树和CSS规则树合并，构建渲染树\n4.reflow(重排)：根据渲染树进行节点信息计算\n5.repaint(重绘):根据计算好的信息绘制整个页面\n")])])]),s("h2",{attrs:{id:"浏览器内核可以分四种-trident、gecko、blink、webkit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核可以分四种-trident、gecko、blink、webkit"}},[a._v("#")]),a._v(" 浏览器内核可以分四种：Trident、Gecko、Blink、Webkit")]),a._v(" "),s("h2",{attrs:{id:"常见的浏览器兼容性以及解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的浏览器兼容性以及解决方案"}},[a._v("#")]),a._v(" 常见的浏览器兼容性以及解决方案")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1、不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同\n解决方案： css 里增加通配符 * { margin: 0; padding: 0; }\n2、IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题\n解决方案：设置display:inline;\n3、当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度\n解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度\n4、图片默认有间距\n解决方案：使用float 为img 布局\n5、IE9一下浏览器不能使用opacity\n解决方案：opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);\n6、边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；\n解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；\n7、cursor:hand 显示手型在safari 上不支持\n解决方案：统一使用 cursor:pointer\n8、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；\n解决方案：父级元素设置position:relative\n")])])]),s("h2",{attrs:{id:"浏览器缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("当浏览器访问过后的资源，会被浏览器缓存的本地，当下次在访问页面的时候，如果没有过期，直接读取缓存，加快浏览器的加载效率\n")])])]),s("h2",{attrs:{id:"浏览器缓存分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存分类"}},[a._v("#")]),a._v(" 浏览器缓存分类")]),a._v(" "),s("h3",{attrs:{id:"_1-强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-强缓存"}},[a._v("#")]),a._v(" 1.强缓存")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("强缓存是利用 Expires 和 Cache-Control 这2个字段来控制的，控制资源缓存的时间，在有效期内不会去向服务器请求了\n")])])]),s("h3",{attrs:{id:"_2-协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-协商缓存"}},[a._v("#")]),a._v(" 2.协商缓存")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("协商缓存是由服务器来确定缓存资源是否可用 ，需要服务器和客户端一起配合。\n服务器可在 response header 中包含Last-Modified字段或者ETag字段\n")])])]),s("h2",{attrs:{id:"浏览器垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器垃圾回收机制"}},[a._v("#")]),a._v(" 浏览器垃圾回收机制")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("老：标记清除算法，GC会检测当前对象有没有被变量所引用，如果没有就回收。\n新： Scavenge ，把内存空间分为两部分，分别为 From 空间和 To 空间。\n当一个空间满了以后，会把空间中活动对象转移到另外一个空间，这样互换。\n")])])]),s("h3",{attrs:{id:"事件委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[a._v("#")]),a._v(" 事件委托")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("事件委托本质上是利用了浏览器事件冒泡的机制。\n因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，\n因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗 ，也是常见的JS性能优化的一个点\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);